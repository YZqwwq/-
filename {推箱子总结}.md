## ~{推箱子总结}~

------

#### 1.垃圾话：

作为我的首个java练手项目，前前后后大概写了20来天（龟爬），几乎是从零开始的重新学了一遍，对什么是面向对象（面向cv）有了一些理解。这个项目结合了io流的一点东西，网络的一点东西，数据库的一点东西，以及最基础的java。基本实现了推箱子的大部分功能，有一些额外的想法或基于能力或基于懒也就没有实现，代码也是屎山，注释基本等于没有，希望看的不要太难受。

##### 实现功能：

1.所有推箱子的基础功能

2.基于本地数据库的登录系统，有检查登录是否正确的功能

3.基于本地数据库的注册系统，可以检查密码设置（正则判断）

4.对于每一个玩家的显示

5.对于每一关通过的计时

6.上一关 ，下一关，选择关，撤回，重玩关卡

7.实现了背景音乐的循环播放

### 关于SWING类，AWT 类的一些说明

##### 1.说明：

首先 swing 是 java 对 awt（基于c/cpp） 组件做的升级，涵盖了 awt 的所有功能  ，解决的绝大多数 awt 组件的问题，且跨平台性能优秀，但 awt 在一些情况下运行速度更快，暂不做表述。

##### 2.Jframe 

**演示： **

```java
public static void main(String[] args) {
        JFrame jFrame = new JFrame();
        JLabel jLabel = new JLabel("nihao");

        jFrame.setSize(400,300);//(width,height)设置宽高
        //jFrame.setBounds();设置位置和宽高

        jFrame.setResizable(false);//设置窗口不可动
        jFrame.setLocationRelativeTo(null);//居中布局
        jFrame.setLayout(null);//设置窗口布局模式

        jLabel.setBounds(110,100,40,20);

        jFrame.add(jLabel);//将jLabel加入到布局
        jFrame.setVisible(true);//窗口可视
        jFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);//设置关闭后结束程序
    }
```

可直接添加label text password等组件

##### 3.Jpanel

顾名思义 Jfame 为框架（基级），Jpanel为面板，框架中可以放下jpanel，menubar等组件。

Jpanel可实现内组件摆放与其他组件的的添加有上下级关系

其中图片绘制（paint方法）在上面实现



## 推箱子代码

#### 1.Game(main)启动项

```java
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Iterator;

public class Game extends JFrame implements ActionListener {
    JMenuBar menuBar = new JMenuBar();

    JMenu opration = new JMenu("选项");
    JMenu game = new JMenu("游戏");
    JMenu help = new JMenu("帮助");

    //定义初始菜单列表

    JMenu menuInMenu = new JMenu("菜单中菜单");
    JMenuItem menuItem = new JMenuItem("菜单选项");

    ButtonPanel buttonPanel = new ButtonPanel();

    public Game() throws Exception {
        this.setSize(730, 655);
        this.setTitle("推箱子");
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        this.setLocationRelativeTo(null);
        BufferedImage image = ImageIO.read(new File("file/txz/icon.jpg"));
        this.setResizable(false);//设置窗口不可动
        this.setLayout(null);//居中布局
        this.setIconImage(image);//设置基本标致
        this.add(menuBar);//添加顶部布局

        addPanel();
        addMenu();//设置顶部布局
        addListener();

        this.setVisible(true);
    }

    private void addMenu() {
        menuBar.setBounds(0, 0, 730, 20);
        menuBar.add(opration);
        menuBar.add(game);
        menuBar.add(help);

        opration.add(menuInMenu);
        menuInMenu.add(menuItem);
    }

    private void addPanel() {
        this.add(Gamepanel.getGamepanel());
        this.add(buttonPanel);
    }

    public static void main(String[] args) throws Exception {
        new Game();
    }

    private void addListener() {
        buttonPanel.firstBt.addActionListener(this);
        buttonPanel.nextBt.addActionListener(this);
        buttonPanel.lastBt.addActionListener(this);
        buttonPanel.choiceBt.addActionListener(this);
        buttonPanel.preBt.addActionListener(this);
        buttonPanel.replay.addActionListener(this);
        buttonPanel.back.addActionListener(this);

    }

    @Override
    public void actionPerformed(ActionEvent e) {

        Object source = e.getSource();
        //System.out.println(source);//source打印

        if (source == buttonPanel.firstBt) {//首关
           Level.Level=0;
           Gamepanel.getGamepanel().readMap(Level.Level);
           //重新加载地图
           Chehuistack.getChehuistack().mapstack.clear();
           //清空数组撤回列表，重新建立
            long start =System.currentTimeMillis();
            Time.getstart(start);
            Gamepanel.getGamepanel().setEnabled(true);

        } else if (source == buttonPanel.preBt) {//上一关
            Gamepanel.getGamepanel().setEnabled(true);
            if (Level.Level != 0) {
                Chehuistack.getChehuistack().mapstack.clear();

                long start =System.currentTimeMillis();
                Time.getstart(start);
                Level.Level--;
                Gamepanel.getGamepanel().readMap(Level.Level);
            }

        } else if (source == buttonPanel.nextBt) {//下一关
            Gamepanel.getGamepanel().setEnabled(true);
            if (Level.Level != 4) {
                Chehuistack.getChehuistack().mapstack.clear();

                long start =System.currentTimeMillis();
                Time.getstart(start);
                Level.Level++;
                Gamepanel.getGamepanel().readMap(Level.Level);
            }
        } else if (source == buttonPanel.lastBt) {//最后一关
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            long start =System.currentTimeMillis();
            Time.getstart(start);
            Level.Level=4;
            Gamepanel.getGamepanel().readMap(Level.Level);
        } else if (source == buttonPanel.choiceBt) {//选择关
            Object choice[] = {0,1,2,3,4};
            Object checked = JOptionPane.showInputDialog(this,"请选择关卡：","选择关",JOptionPane.INFORMATION_MESSAGE,null,choice,choice[0]);

            Level.Level=(int)checked;
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            Gamepanel.getGamepanel().readMap(Level.Level);
            long start =System.currentTimeMillis();
            Time.getstart(start);

        }else if (source==buttonPanel.replay){//重玩
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            long start =System.currentTimeMillis();
            Time.getstart(start);
            Gamepanel.getGamepanel().readMap(Level.Level);

        }else if (source == buttonPanel.back){//撤回

            if (! Chehuistack.getChehuistack().mapstack.isEmpty()){
                char[][] guoji =   Chehuistack.getChehuistack().mapstack.pop();

                for (int i = 0; i < guoji.length; i++) {
                    for (int j = 0; j < guoji[i].length; j++) {
                        Gamepanel.getGamepanel().tempmap[i][j] = guoji[i][j];
                    }
                }//将拿到的的地图重新赋给temper暂存图
                System.out.println("123");
            }
            Gamepanel.getGamepanel().houChe();//拿到判断外，一定要重获焦点
        }
        Gamepanel.getGamepanel().tempmap.toString();
    }
}
```

##### 1.addmenu

```
 private void addMenu() {
        menuBar.setBounds(0, 0, 730, 20);
        menuBar.add(opration);
        menuBar.add(game);
        menuBar.add(help);

        opration.add(menuInMenu);
        menuInMenu.add(menuItem);
    }
```

添加上层menu选项栏

##### 2.addPanel

```
  private void addPanel() {
        this.add(Gamepanel.getGamepanel());
        this.add(buttonPanel);
    }
```

添加 上层游戏显示面板

##### 3.addLIstener()

```
 private void addListener() {
        buttonPanel.firstBt.addActionListener(this);
        buttonPanel.nextBt.addActionListener(this);
        buttonPanel.lastBt.addActionListener(this);
        buttonPanel.choiceBt.addActionListener(this);
        buttonPanel.preBt.addActionListener(this);
        buttonPanel.replay.addActionListener(this);
        buttonPanel.back.addActionListener(this);
    }
```

为按钮逐一增加监听

##### 4.actionPerformed(ActionEvent e)

```java
  @Override
    public void actionPerformed(ActionEvent e) {

        Object source = e.getSource();
        //System.out.println(source);//source打印

        if (source == buttonPanel.firstBt) {//首关
           Level.Level=0;
           Gamepanel.getGamepanel().readMap(Level.Level);
           //重新加载地图
           Chehuistack.getChehuistack().mapstack.clear();
           //清空数组撤回列表，重新建立
            long start =System.currentTimeMillis();
            Time.getstart(start);
            Gamepanel.getGamepanel().setEnabled(true);

        } else if (source == buttonPanel.preBt) {//上一关
            Gamepanel.getGamepanel().setEnabled(true);
            if (Level.Level != 0) {
                Chehuistack.getChehuistack().mapstack.clear();

                long start =System.currentTimeMillis();
                Time.getstart(start);
                Level.Level--;
                Gamepanel.getGamepanel().readMap(Level.Level);
            }

        } else if (source == buttonPanel.nextBt) {//下一关
            Gamepanel.getGamepanel().setEnabled(true);
            if (Level.Level != 4) {
                Chehuistack.getChehuistack().mapstack.clear();

                long start =System.currentTimeMillis();
                Time.getstart(start);
                Level.Level++;
                Gamepanel.getGamepanel().readMap(Level.Level);
            }
        } else if (source == buttonPanel.lastBt) {//最后一关
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            long start =System.currentTimeMillis();
            Time.getstart(start);
            Level.Level=4;
            Gamepanel.getGamepanel().readMap(Level.Level);
        } else if (source == buttonPanel.choiceBt) {//选择关
            Object choice[] = {0,1,2,3,4};
            Object checked = JOptionPane.showInputDialog(this,"请选择关卡：","选择关",JOptionPane.INFORMATION_MESSAGE,null,choice,choice[0]);

            Level.Level=(int)checked;
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            Gamepanel.getGamepanel().readMap(Level.Level);
            long start =System.currentTimeMillis();
            Time.getstart(start);

        }else if (source==buttonPanel.replay){//重玩
            Gamepanel.getGamepanel().setEnabled(true);
            Chehuistack.getChehuistack().mapstack.clear();

            long start =System.currentTimeMillis();
            Time.getstart(start);
            Gamepanel.getGamepanel().readMap(Level.Level);

        }else if (source == buttonPanel.back){//撤回

            if (! Chehuistack.getChehuistack().mapstack.isEmpty()){
                char[][] guoji =   Chehuistack.getChehuistack().mapstack.pop();

                for (int i = 0; i < guoji.length; i++) {
                    for (int j = 0; j < guoji[i].length; j++) {
                        Gamepanel.getGamepanel().tempmap[i][j] = guoji[i][j];
                    }
                }//将拿到的的地图重新赋给temper暂存图
                System.out.println("123");
            }
            Gamepanel.getGamepanel().houChe();//拿到判断外，一定要重获焦点
        }
    }
```

###### first.

 

       @Override
        public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        }

作为 actionPerforme的重写方法 我们在其中实现我们想要的功能

source 是被监听的内容 我们根据 source 得到的内容 来判断是否需要执行命名

例如：

###### 首关

```java
 if (source == buttonPanel.firstBt) {//首关
           Level.Level=0;
           Gamepanel.getGamepanel().readMap(Level.Level);
           //重新加载地图
           Chehuistack.getChehuistack().mapstack.clear();
           //清空数组撤回列表，重新建立
            long start =System.currentTimeMillis();
            Time.getstart(start);
            Gamepanel.getGamepanel().setEnabled(true);
        }
```

###### 一些需要主要的点

```java
else if (source == buttonPanel.nextBt) {//下一关
            Gamepanel.getGamepanel().setEnabled(true);
            if (Level.Level != 4) {
                Chehuistack.getChehuistack().mapstack.clear();

                long start =System.currentTimeMillis();
                Time.getstart(start);
                Level.Level++;
                Gamepanel.getGamepanel().readMap(Level.Level);
            }
```

 Gamepanel.getGamepanel().setEnabled(true);

这一句需要放在if（）外，否则会造成无法恢复操作

```java
       else if (source == buttonPanel.back){//撤回

            if (! Chehuistack.getChehuistack().mapstack.isEmpty()){
                char[][] guoji =   Chehuistack.getChehuistack().mapstack.pop();

                for (int i = 0; i < guoji.length; i++) {
                    for (int j = 0; j < guoji[i].length; j++) {
                        Gamepanel.getGamepanel().tempmap[i][j] = guoji[i][j];
                    }
                }//将拿到的的地图重新赋给temper暂存图
            }
            Gamepanel.getGamepanel().houChe();//拿到判断外，一定要重获焦点
        }
```

 Gamepanel.getGamepanel().houChe();//拿到判断外，一定要重获焦点，不然当撤回次数超过栈时会丢失焦点导致无法运行

houChe()在后面写Panel的时候会看到

#### 2.ButtonPanel

```java
import javax.swing.*;
import java.awt.*;
public class ButtonPanel extends JPanel {
    JButton firstBt = new JButton("第一关");
    JButton back = new JButton("撤回");

    JButton lastBt = new JButton("最终关");

    JButton nextBt = new JButton("下一关");

    JButton preBt = new JButton("上一关");

    JButton choiceBt = new JButton("选择关");

    JButton replay = new JButton("重玩");
    
    public ButtonPanel() {
        this.setBounds(600, 20, 120, 600);
        this.setBackground(new Color(0xD3718B));//随意的调整颜色

        addButton();//管他，反正同类中this可写可不写
    }
    
    private void addButton() {
        Box verticalBox = Box.createVerticalBox();
        //创建盒模型，为项目加支撑
        verticalBox.add(Box.createVerticalStrut(30));
        verticalBox.add(replay);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(back);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(firstBt);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(lastBt);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(nextBt);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(preBt);
        verticalBox.add(Box.createVerticalStrut(50));
        verticalBox.add(choiceBt);
        this.add(verticalBox);
    }
}
```

盒模型相当于透明框架起到按钮间分隔作用

#### 3.GamePanel

```java


import javax.crypto.spec.PSource;
import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Stack;

public class Gamepanel extends JPanel implements KeyListener {//继承后成为panel，在内部设定即可
    static int a = 1;
    private static char[][] map;
    protected char[][] tempmap;

    public void setMonkeyX(int monkeyX) {
        this.monkeyX = monkeyX;
    }

    public void setMonkeyY(int monkeyY) {
        this.monkeyY = monkeyY;
    }

    private int monkeyX;
    private int monkeyY;
    //创建地图
    Win win = new Win();

    Toolkit toolkit = Toolkit.getDefaultToolkit();//从磁盘中导出

    private char wall = '1';//不可移动

    private char tree = '2';//可覆盖

    private char box = '3';//可移动遇墙不可移动

    private char destination = '4';

    private char monkeyDown = '5';

    private char monkeyLeft = '6';

    private char monkeyRight = '7';

    private char monkeyUp = '8';

    private char finalBox = '9';

    Image[] images = {
            toolkit.getImage("file/txz/0.png"),
            toolkit.getImage("file/txz/1.png"),
            toolkit.getImage("file/txz/2.png"),
            toolkit.getImage("file/txz/3.png"),
            toolkit.getImage("file/txz/4.png"),
            toolkit.getImage("file/txz/5.png"),
            toolkit.getImage("file/txz/6.png"),
            toolkit.getImage("file/txz/7.png"),
            toolkit.getImage("file/txz/8.png"),
            toolkit.getImage("file/txz/9.png"),
    };

    public void paint(Graphics g) {//无需使用会被自动调用一次
        super.paint(g);
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                char point = tempmap[i][j];
                int index = Integer.parseInt(String.valueOf(point));
                g.drawImage(images[index], j * 30, i * 30, 30, 30, this);
            }
        }
        this.requestFocus();//不需要
    }

    private static Gamepanel gamepanel = new Gamepanel();

    public static Gamepanel getGamepanel() {
        return gamepanel;
    }//设置为单例模式

    private Gamepanel() {
        this.setSize(600, 600);
        this.setLocation(0, 20);
        this.setBackground(new Color(0xFF45F3E1, true));

        this.addKeyListener(this);//添加监听器

        readMap(0);
    }

    public void readMap(int level1) {
        Map map = new Map(Level.Level);//源地图

        tempmap = new Map(Level.Level).getMap();//临时地图
        this.map = map.getMap();

        this.monkeyX = map.getMonkeyX();//人物行位置
        this.monkeyY = map.getMonkeyY();//人物列位置

        this.requestFocus();//重绘后请求焦点
        repaint();
        //读取后重绘地图
    }

    public void houChe() {
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                if (tempmap[i][j] == '5' || tempmap[i][j] == '6' || tempmap[i][j] == '7' || tempmap[i][j] == '8') {
                    this.monkeyX = i;
                    this.monkeyY = j;
                    System.out.println(i);
                    System.out.println(j);
                }
            }
        }
        System.out.println("123");
        this.requestFocus();
        repaint();
    }

    public char[][] getMap() {
        return map;
    }

    public void judgeWin() throws Exception {
        if (win.judgePanel(tempmap) == true && Level.Level != 4) {
            Chehuistack.getChehuistack().mapstack.clear();
            this.setEnabled(false);
            new WinFrame();
        } else if (win.judgePanel(tempmap) == true && Level.Level == 4) {
            Chehuistack.getChehuistack().mapstack.clear();
            this.setEnabled(false);
            new WinFrame2();
        }
    }

    private void goLeft() {
        cunMap();

        if (tempmap[monkeyX][monkeyY - 1] == '1') {
            tempmap[monkeyX][monkeyY] = '6';//turn left
        }//1单人物，左侧无箱子，不能走

        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '1') {//2箱子到头
            tempmap[monkeyX][monkeyY] = '6';
        }
        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '1') {//3箱子到头且终点
            tempmap[monkeyX][monkeyY] = '6';
        }

        //左边有两箱子
        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '3') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '3') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '9') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '9') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] != '3' && tempmap[monkeyX][monkeyY - 1] != '9') {//4单人物，左侧无箱子，能走
            if (tempmap[monkeyX][monkeyY - 1] != '1') {
                tempmap[monkeyX][monkeyY - 1] = '6';//左侧一格变为向左人物
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                monkeyY--;//修订monkeyY位置

            }

        } else if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] != '1') {//5单人物左侧有箱子
            if (tempmap[monkeyX][monkeyY - 2] != '3' && tempmap[monkeyX][monkeyY - 2] != '9') {//能走
                tempmap[monkeyX][monkeyY - 1] = '6';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物码，下方为箱子码
                if (map[monkeyX][monkeyY - 2] == '4') {
                    tempmap[monkeyX][monkeyY - 2] = '9';
                } else tempmap[monkeyX][monkeyY - 2] = '3';
                monkeyY--;

            }
        } else if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] != '1') {//6箱子位置为终点，可动
            if (tempmap[monkeyX][monkeyY - 2] != '3' && tempmap[monkeyX][monkeyY - 2] != '9') {
                tempmap[monkeyX][monkeyY - 1] = '6';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX][monkeyY - 2] == '4') {
                    tempmap[monkeyX][monkeyY - 2] = '9';
                } else tempmap[monkeyX][monkeyY - 2] = '3';
                monkeyY--;

            }
        }

        repaint();// 此处走一步动了两次？？
    }

    /*想左走后改变tempmap，重绘地图（repain）
     * 人物monkeyX，monkeyY
     * this.monkeyX = map.getMonkeyX();
     * this.monkeyY = map.getMonkeyY();
     * 与原地图map比较得到位置*/

    private void goRight() {
        cunMap();

        if (tempmap[monkeyX][monkeyY + 1] == '1') {
            tempmap[monkeyX][monkeyY] = '7';//turn right
        }//1单人物，右侧无箱子，不能走

        if (tempmap[monkeyX][monkeyY + 1] == '3' && tempmap[monkeyX][monkeyY + 2] == '1') {//2箱子到头
            tempmap[monkeyX][monkeyY] = '7';
        }
        if (tempmap[monkeyX][monkeyY + 1] == '9' && tempmap[monkeyX][monkeyY + 2] == '1') {//3箱子到头且终点
            tempmap[monkeyX][monkeyY] = '7';
        }

        if (tempmap[monkeyX][monkeyY + 1] == '3' && tempmap[monkeyX][monkeyY + 2] == '3') {
            tempmap[monkeyX][monkeyY] = '7';
        }

        if (tempmap[monkeyX][monkeyY + 1] == '9' && tempmap[monkeyX][monkeyY + 2] == '3') {
            tempmap[monkeyX][monkeyY] = '7';
        }

        if (tempmap[monkeyX][monkeyY + 1] == '9' && tempmap[monkeyX][monkeyY + 2] == '9') {
            tempmap[monkeyX][monkeyY] = '7';
        }

        if (tempmap[monkeyX][monkeyY + 1] == '3' && tempmap[monkeyX][monkeyY + 2] == '9') {
            tempmap[monkeyX][monkeyY] = '7';
        }
        if (tempmap[monkeyX][monkeyY + 1] != '3' && tempmap[monkeyX][monkeyY + 1] != '9') {  //4单人物，右侧无箱子，能走
            if (tempmap[monkeyX][monkeyY + 1] != '1') {
                tempmap[monkeyX][monkeyY + 1] = '7';//左侧一格变为向左人物
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                monkeyY++;//修订monkeyY位置
            }
        } else if (tempmap[monkeyX][monkeyY + 1] == '3' && tempmap[monkeyX][monkeyY + 2] != '1') {//5单人物右侧有箱子
            if (tempmap[monkeyX][monkeyY + 2] != '3' && tempmap[monkeyX][monkeyY + 2] != '9') {
                tempmap[monkeyX][monkeyY + 1] = '7';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX][monkeyY + 2] == '4') {
                    tempmap[monkeyX][monkeyY + 2] = '9';
                } else tempmap[monkeyX][monkeyY + 2] = '3';
                monkeyY++;

            }
        } else if (tempmap[monkeyX][monkeyY + 1] == '9' && tempmap[monkeyX][monkeyY + 2] != '1') {//6箱子位置为终点，可动
            if (tempmap[monkeyX][monkeyY + 2] != '3' && tempmap[monkeyX][monkeyY + 2] != '9') {
                tempmap[monkeyX][monkeyY + 1] = '7';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX][monkeyY + 2] == '4') {
                    tempmap[monkeyX][monkeyY + 2] = '9';
                } else tempmap[monkeyX][monkeyY + 2] = '3';
                monkeyY++;

            }
        }

        repaint();
    }

    private void goUp() {
        cunMap();

        if (tempmap[monkeyX - 1][monkeyY] == '1') {
            tempmap[monkeyX][monkeyY] = '8';//turn up
        }//1单人物，右侧无箱子，不能走

        if (tempmap[monkeyX - 1][monkeyY] == '8' && tempmap[monkeyX - 2][monkeyY] == '1') {//2箱子到头
            tempmap[monkeyX][monkeyY] = '8';
        }
        if (tempmap[monkeyX - 1][monkeyY] == '8' && tempmap[monkeyX - 2][monkeyY] == '1') {//3箱子到头且终点
            tempmap[monkeyX][monkeyY] = '8';
        }

        if (tempmap[monkeyX - 1][monkeyY] == '3' && tempmap[monkeyX - 2][monkeyY] == '3') {
            tempmap[monkeyX][monkeyY] = '8';
        }

        if (tempmap[monkeyX - 1][monkeyY] == '9' && tempmap[monkeyX - 2][monkeyY] == '3') {
            tempmap[monkeyX][monkeyY] = '8';
        }

        if (tempmap[monkeyX - 1][monkeyY] == '9' && tempmap[monkeyX - 2][monkeyY] == '9') {
            tempmap[monkeyX][monkeyY] = '8';
        }

        if (tempmap[monkeyX - 1][monkeyY] == '3' && tempmap[monkeyX - 2][monkeyY] == '9') {
            tempmap[monkeyX][monkeyY] = '8';
        }

        if (tempmap[monkeyX - 1][monkeyY] != '3' && tempmap[monkeyX - 1][monkeyY] != '9') {  //4单人物，右侧无箱子，能走
            if (tempmap[monkeyX - 1][monkeyY] != '1') {
                tempmap[monkeyX - 1][monkeyY] = '8';//左侧一格变为向左人物
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                monkeyX--;//修订monkeyY位置
            }
        } else if (tempmap[monkeyX - 1][monkeyY] == '3' && tempmap[monkeyX - 2][monkeyY] != '1') {//5单人物右侧有箱子
            if (tempmap[monkeyX - 2][monkeyY] != '3' && tempmap[monkeyX - 2][monkeyY] != '9') {
                tempmap[monkeyX - 1][monkeyY] = '8';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX - 2][monkeyY] == '4') {
                    tempmap[monkeyX - 2][monkeyY] = '9';
                } else tempmap[monkeyX - 2][monkeyY] = '3';

                monkeyX--;
            }
        } else if (tempmap[monkeyX - 1][monkeyY] == '9' && tempmap[monkeyX - 2][monkeyY] != '1') {//6箱子位置为终点，可动
            if (tempmap[monkeyX - 2][monkeyY] != '3' && tempmap[monkeyX - 2][monkeyY] != '9') {
                tempmap[monkeyX - 1][monkeyY] = '8';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX - 2][monkeyY] == '4') {
                    tempmap[monkeyX - 2][monkeyY] = '9';
                } else tempmap[monkeyX - 2][monkeyY] = '3';
                monkeyX--;
            }
        }
        repaint();
    }

    private void goDown() {
        cunMap();

        if (tempmap[monkeyX + 1][monkeyY] == '1') {
            tempmap[monkeyX][monkeyY] = '5';//turn right
        }//1单人物，右侧无箱子，不能走

        if (tempmap[monkeyX + 1][monkeyY] == '3' && tempmap[monkeyX + 2][monkeyY] == '1') {//2箱子到头
            tempmap[monkeyX][monkeyY] = '5';
        }
        if (tempmap[monkeyX + 1][monkeyY] == '9' && tempmap[monkeyX + 2][monkeyY] == '1') {//3箱子到头且终点
            tempmap[monkeyX][monkeyY] = '5';
        }
        if (tempmap[monkeyX + 1][monkeyY] == '3' && tempmap[monkeyX + 2][monkeyY] == '3') {
            tempmap[monkeyX][monkeyY] = '5';
        }

        if (tempmap[monkeyX + 1][monkeyY] == '9' && tempmap[monkeyX - 2][monkeyY] == '3') {
            tempmap[monkeyX][monkeyY] = '5';
        }

        if (tempmap[monkeyX + 1][monkeyY] == '9' && tempmap[monkeyX - 2][monkeyY] == '9') {
            tempmap[monkeyX][monkeyY] = '5';
        }

        if (tempmap[monkeyX + 1][monkeyY] == '3' && tempmap[monkeyX + 2][monkeyY] == '9') {
            tempmap[monkeyX][monkeyY] = '5';
        }


        if (tempmap[monkeyX + 1][monkeyY] != '3' && tempmap[monkeyX + 1][monkeyY] != '9') {  //4单人物，右侧无箱子，能走
            if (tempmap[monkeyX + 1][monkeyY] != '1') {
                tempmap[monkeyX + 1][monkeyY] = '5';//左侧一格变为向左人物
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                monkeyX++;//修订monkeyY位置
            }
        } else if (tempmap[monkeyX + 1][monkeyY] == '3' && tempmap[monkeyX + 2][monkeyY] != '1') {//5单人物右侧有箱子
            if (tempmap[monkeyX + 2][monkeyY] != '3' && tempmap[monkeyX + 2][monkeyY] != '9') {
                tempmap[monkeyX + 1][monkeyY] = '5';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX + 2][monkeyY] == '4') {
                    tempmap[monkeyX + 2][monkeyY] = '9';
                } else tempmap[monkeyX + 2][monkeyY] = '3';
                monkeyX++;
            }
        } else if (tempmap[monkeyX + 1][monkeyY] == '9' && tempmap[monkeyX + 2][monkeyY] != '1') {//6箱子位置为终点，可动
            if (tempmap[monkeyX + 2][monkeyY] != '3' && tempmap[monkeyX + 2][monkeyY] != '9') {
                tempmap[monkeyX + 1][monkeyY] = '5';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX + 2][monkeyY] == '4') {
                    tempmap[monkeyX + 2][monkeyY] = '9';
                } else tempmap[monkeyX + 2][monkeyY] = '3';

                monkeyX++;
            }
        }
        repaint();
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) {
            goLeft();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        } else if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) {
            goRight();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        } else if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) {
            goUp();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        } else if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) {
            goDown();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    public void cunMap() {
        char[][] chengjie = new char[20][20];
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                chengjie[i][j] = tempmap[i][j];
            }
        }

        Chehuistack.getChehuistack().mapstack.push(chengjie);//每次移动将新地图加入stack队列

         /*Stack<char[][]> my = Chehuistack.getChehuistack().mapstack;

          for (int i = 0; i < my.size(); i++) {
            ToString(my.get(i));
        }测试拿到的地图*/
    }

    public void ToString(char[][] m) {
        for (int i = 0; i < m.length; i++) {
            for (int j = 0; j < m[i].length; j++) {
                System.out.print(m[i][j]);
            }
            System.out.println();
        }
        System.out.println();
    }
}
```

##### 1.private Gamepanel() 

```java
private Gamepanel() {
    this.setSize(600, 600);
    this.setLocation(0, 20);
    this.setBackground(new Color(0xFF45F3E1, true));

    this.addKeyListener(this);//添加监听器
    
    readMap(0);//接下来会说
}
```

##### 2.基础配置

```java
    static int a = 1;
    private static char[][] map;
    protected char[][] tempmap;

    public void setMonkeyX(int monkeyX) {
        this.monkeyX = monkeyX;
    }

    public void setMonkeyY(int monkeyY) {
        this.monkeyY = monkeyY;
    }

    private int monkeyX;
    private int monkeyY;
    //创建地图
    Win win = new Win();

    Toolkit toolkit = Toolkit.getDefaultToolkit();//从磁盘中导出

    private char wall = '1';//不可移动

    private char tree = '2';//可覆盖

    private char box = '3';//可移动遇墙不可移动

    private char destination = '4';

    private char monkeyDown = '5';

    private char monkeyLeft = '6';

    private char monkeyRight = '7';

    private char monkeyUp = '8';

    private char finalBox = '9';

    Image[] images = {
            toolkit.getImage("file/txz/0.png"),
            toolkit.getImage("file/txz/1.png"),
            toolkit.getImage("file/txz/2.png"),
            toolkit.getImage("file/txz/3.png"),
            toolkit.getImage("file/txz/4.png"),
            toolkit.getImage("file/txz/5.png"),
            toolkit.getImage("file/txz/6.png"),
            toolkit.getImage("file/txz/7.png"),
            toolkit.getImage("file/txz/8.png"),
            toolkit.getImage("file/txz/9.png"),
    };
```

tookit 工具栏，拿file

##### 3.paint

```java
@Override
public void paint(Graphics g) {//无需使用会被自动调用一次
        super.paint(g);
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                char point = tempmap[i][j];
                int index = Integer.parseInt(String.valueOf(point));
                g.drawImage(images[index], j * 30, i * 30, 30, 30, this);
            }
        }
        this.requestFocus();//不需要
    }
```

重写了override方法无需在Main类中调用，

此处无需获取焦点。

由于二维数组中 i ，j 的定义顺序正好和 通常意义上的二维空间相反（x,y）故需要在绘制图片时调换顺序

##### 4.设置单例模式

```java
 private static Gamepanel gamepanel = new Gamepanel();

    public static Gamepanel getGamepanel() {
        return gamepanel;
    }//设置为单例模式
```

由于接下来中我们需要用到的panel都是同一块所以不能每次开新地图都new panel 故需要使用单例。

单例模式：

此处仅做两种简单案例

###### 懒汉：内存无浪费 ，但线程不安全

```java
public class DanLi{

  private static Danli danli = null;

   public static getDanli(){
    if(danli == null){
        
    danli = new Danli();
        
    }
  return danli;
 }
}
```

###### 饿汉：会造成内存浪费，线程安全

```java
public class DanLi{
   private static Danli danli = new Danli;
   
   public static getDanli(){
      return danli;
   }
}
```

##### 5.构造

```java
private Gamepanel() {
        this.setSize(600, 600);
        this.setLocation(0, 20);
        this.setBackground(new Color(0xFF45F3E1, true));

        this.addKeyListener(this);//添加监听器

        readMap(0);
    }
```

##### 6.readMap

```java
 public void readMap(int level1) {
        Map map = new Map(Level.Level);//源地图

        tempmap = new Map(Level.Level).getMap();//临时地图
        this.map = map.getMap();

        this.monkeyX = map.getMonkeyX();//人物行位置
        this.monkeyY = map.getMonkeyY();//人物列位置

        this.requestFocus();//重绘后请求焦点
        repaint();
        //读取后重绘地图
    }
```

repaint 为paint 默认的方法 无需自己写

此处需要配合Map类理解

简单来说就是 创建每个关卡的初始地图

##### 7.houChe

```java
public void houChe() {
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                if (tempmap[i][j] == '5' || tempmap[i][j] == '6' || tempmap[i][j] == '7' || tempmap[i][j] == '8') {
                    this.monkeyX = i;
                    this.monkeyY = j;
                    System.out.println(i);
                    System.out.println(j);
                }
            }
        }
        System.out.println("123");
        this.requestFocus();
        repaint();
    }
```

撤回的的方法实现，此处于Game中的后撤方法有关

##### 8.getMap

```java
public char[][] getMap() {
    return map;
}
```

读取本次地图 后面的WinFrame类会用到

##### 9.judgeWin

```java
public void judgeWin() throws Exception {
    if (win.judgePanel(tempmap) == true && Level.Level != 4) {
        Chehuistack.getChehuistack().mapstack.clear();//清空后撤栈
        this.setEnabled(false);
        new WinFrame();
    } else if (win.judgePanel(tempmap) == true && Level.Level == 4) {//此处不一定是4，看最后一张地图是什么
        Chehuistack.getChehuistack().mapstack.clear();
        this.setEnabled(false);
        new WinFrame2();
    }
}
```

判断箱子是否全部进入

##### 10.行走动作（以左为例）

```java
private void goLeft() {
        cunMap();

        if (tempmap[monkeyX][monkeyY - 1] == '1') {
            tempmap[monkeyX][monkeyY] = '6';//turn left
        }//1单人物，左侧无箱子，不能走

        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '1') {//2箱子到头
            tempmap[monkeyX][monkeyY] = '6';
        }
        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '1') {//3箱子到头且终点
            tempmap[monkeyX][monkeyY] = '6';
        }

        //左边有两箱子
        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '3') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '3') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] == '9') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] == '9') {
            tempmap[monkeyX][monkeyY] = '6';
        }

        if (tempmap[monkeyX][monkeyY - 1] != '3' && tempmap[monkeyX][monkeyY - 1] != '9') {//4单人物，左侧无箱子，能走
            if (tempmap[monkeyX][monkeyY - 1] != '1') {
                tempmap[monkeyX][monkeyY - 1] = '6';//左侧一格变为向左人物
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                monkeyY--;//修订monkeyY位置

            }

        } else if (tempmap[monkeyX][monkeyY - 1] == '3' && tempmap[monkeyX][monkeyY - 2] != '1') {//5单人物左侧有箱子
            if (tempmap[monkeyX][monkeyY - 2] != '3' && tempmap[monkeyX][monkeyY - 2] != '9') {//能走
                tempmap[monkeyX][monkeyY - 1] = '6';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物码，下方为箱子码
                if (map[monkeyX][monkeyY - 2] == '4') {
                    tempmap[monkeyX][monkeyY - 2] = '9';
                } else tempmap[monkeyX][monkeyY - 2] = '3';
                monkeyY--;

            }
        } else if (tempmap[monkeyX][monkeyY - 1] == '9' && tempmap[monkeyX][monkeyY - 2] != '1') {//6箱子位置为终点，可动
            if (tempmap[monkeyX][monkeyY - 2] != '3' && tempmap[monkeyX][monkeyY - 2] != '9') {
                tempmap[monkeyX][monkeyY - 1] = '6';
                if (map[monkeyX][monkeyY] == '4') {
                    tempmap[monkeyX][monkeyY] = '4';//初始为人物时修正为森林
                } else tempmap[monkeyX][monkeyY] = '2';

                //上方为人物，下方为箱子
                if (map[monkeyX][monkeyY - 2] == '4') {
                    tempmap[monkeyX][monkeyY - 2] = '9';
                } else tempmap[monkeyX][monkeyY - 2] = '3';
                monkeyY--;

            }
        }

        repaint();// 此处走一步动了两次？？
    }
```

cunMap方法在下方

##### 11.重写KeyListenerjiek

```java
    @Override
    public void keyTyped(KeyEvent e) {
        //当打字时调用此方法
    }

    @Override
    public void keyPressed(KeyEvent e) {
        int keyCode = e.getKeyCode();
        if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) {
            goLeft();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);//抛异常
            }
        } else if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) {
            goRight();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        } else if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) {
            goUp();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        } else if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) {
            goDown();
            try {
                judgeWin();
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
```

##### 12.cunMap

```java
 public void cunMap() {
        char[][] chengjie = new char[20][20];
        for (int i = 0; i < tempmap.length; i++) {
            for (int j = 0; j < tempmap[i].length; j++) {
                chengjie[i][j] = tempmap[i][j];
            }
        }

        Chehuistack.getChehuistack().mapstack.push(chengjie);//每次移动将新地图加入stack队列

        Stack<char[][]> my = Chehuistack.getChehuistack().mapstack;
    }
```

这个函数的作用是拿到当前的临时地图

要说的是每次添加入栈的二维数组必须是new以后的，数组不能复用，因为存入的是地址名而不是数组。不然会看到前面存入的数组被覆盖。

#### 4.Level

```java
public class Level {
    static int Level = 0;
}//静态存放等级
```

#### 5.Map

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Stack;

public class Map {
    private char[][] map;

    private int monkeyX;
    private int monkeyY;
    public Map(int level) {

        map = new char[20][20];//创建基础地图

        Scanner Scanner = null;
        try {
            Scanner = new Scanner(new File("file/map/" + level + ".map"));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }//抓取可能发生的异常

        int tempY = 0;

        while (Scanner.hasNextLine()) {
            String line = Scanner.nextLine();
            //System.out.println(line);

            char[] charArray = line.toCharArray();
            for (int i = 0; i < charArray.length; i++) {
                if (charArray[i] == '5') {//主要读到的是字符需要用char类型判断
                    monkeyX = tempY;//tempY为行
                    monkeyY = i;//i代表列
                }
            }
            map[tempY] = charArray;//将每一行存入map
            tempY++;
        }//存放地图，定位人物对象位置

    }

    public char[][] getMap() {
        return map;
    }

    public void setMap(char[][] map) {
        this.map = map;
    }

    public int getMonkeyX() {
        return monkeyX;
    }

    public void setMonkeyX(int monkeyX) {
        this.monkeyX = monkeyX;
    }

    public int getMonkeyY() {
        return monkeyY;
    }

    public void setMonkeyY(int monkeyY) {
        this.monkeyY = monkeyY;
    }

}
```

Map 会去读 File 文件下的 map文件

拿到人物的 X Y坐标 用于GamePanel中的人物运动

map是原始地图，但我们不会操作它，我们需要在GamePanel中创建一个临时地图tempmap去操作它

#### 6.Win

```java
public class Win extends JFrame {

    public Boolean judgePanel(char[][] arr) {

            Boolean Judge = true;
            for (int i = 0; i < arr.length; i++) {
                for (int j = 0; j < arr[i].length; j++) {
                    if (arr[i][j] == '3') {
                        Judge = false;
                    }
                }
            }
        long time =System.currentTimeMillis();
            Time.getend(time);
            return Judge;
    }

}
```

判断是否箱子全部入框

获取时间

#### 7.Time

```java
public class Time {
    static long startTime;

    static long endTime;

    public static void getstart(long time) {
        startTime = time;
    }

    public static void getend(long time) {
        endTime = time;
    }
    public static String getDur()  {

        long diff=(endTime-startTime)/1000;//获取两个时间相差的秒数，毫秒到秒
        System.out.println("两个时间差为：" + diff + "秒");

        long time =System.currentTimeMillis();

        startTime=time;
        return String.valueOf(diff);
    };
}

```

计算时间并输出

#### 8.Chehuistack

```java
import java.util.Stack;

public class Chehuistack {
    //static Stack<char[][]> mapstack = new Stack<>();
    public Stack<char[][]> mapstack = new Stack<>();
    private static Chehuistack chehuistack = new Chehuistack();
    public static Chehuistack getChehuistack (){
        return chehuistack;
    }
}
```

设置单例模式，mapstack要用全场，设置静态会出现覆盖问题（没有测试）；

#### 9. login

```java

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.TextAttribute;
import java.io.File;
import java.sql.*;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class login extends JFrame implements ActionListener, MouseListener, KeyListener {
    ImageIcon box = new ImageIcon("file/txz/box.jpg");

    static JTextField usernameField = new JTextField();

    JPasswordField passwordField = new JPasswordField();

    JLabel usernameLabel = new JLabel("Username");
    JLabel passwordLabel = new JLabel("Password");

    JLabel register = new JLabel("Not Registed Yet?  Creat AN Accout");

    JLabel picture = new JLabel(box);

    JButton firstButton = new JButton("Sign IN");

    HashMap<TextAttribute, Object> hm = new HashMap<TextAttribute, Object>();//设置下划线要用


    public login() throws Exception {

        usernameField.setBounds(270, 50, 250, 50);
        passwordField.setBounds(270, 175, 250, 50);
        usernameLabel.setBounds(50, 50, 200, 50);
        passwordLabel.setBounds(50, 175, 200, 50);

        usernameField.setFont(new Font("微雅软黑", Font.PLAIN, 25));
        passwordField.setFont(new Font("微软雅黑", Font.PLAIN, 25));
        passwordField.addKeyListener(this);

        usernameLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        usernameLabel.setForeground(Color.cyan);

        passwordLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        passwordLabel.setForeground(Color.cyan);

        firstButton.setBounds(120, 280, 350, 80);
        firstButton.setFont(new Font("Goudy Stout", Font.PLAIN, 25));
        firstButton.addActionListener(this);

        hm.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON); // 定义是否有下划线
        hm.put(TextAttribute.SIZE, 12); // 定义字号
        hm.put(TextAttribute.FAMILY, "Simsun"); // 定义字体名
        Font font = new Font(hm); // 生成字号为12，字体为宋体，字形带有下划线的字体

        register.setBounds(140, 380, 210, 20);
        register.setForeground(Color.RED);
        register.setFont(font);
        register.addMouseListener(this);

        picture.setBounds(0, 0, 600, 500);

        componont();
        //设置窗口属性
        Image image = ImageIO.read(new File("file/txz/icon.jpg"));

        this.setIconImage(image);
        this.setTitle("firstwindow");
        this.setSize(620, 490);
        this.setResizable(false);
        this.setLocationRelativeTo(null);
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        this.setLayout(null);
        this.setVisible(true);

    }

    public static String getUser() {
        return usernameField.getText();
    }


    private void componont() {

        this.add(usernameLabel);
        this.add(usernameField);
        this.add(passwordField);
        this.add(passwordLabel);
        this.add(register);
        this.add(firstButton);
        this.add(picture);
    }



    private boolean getUser(String usernameField, String passwordField) throws ClassNotFoundException, SQLException {
        Connection connection = null;
        Statement statement = null;
        ResultSet rs = null;

        try {

            Class.forName("com.mysql.cj.jdbc.Driver");

            String url = "jdbc:mysql://localhost:3306/user?useSSL=FALSE&serverTimezone=UTC";
            String user = "root";
            String password = "mysql$yingzhe";

            connection = DriverManager.getConnection(url, user, password);
            statement = connection.createStatement();

            String sql = ("select * from user where name='" + usernameField + "' ");

            rs = statement.executeQuery(sql);

            if (rs.next()) {
                String ps = rs.getString("password");
                if (ps.equals(passwordField)) {
                    return true;
                }
            }
            connection.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }//释放内存

        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        new login();
    }


    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_ENTER) {
            String passwordInField = new String(passwordField.getPassword());
            String usernameFieldText = usernameField.getText();

            try {
                if (getUser(usernameFieldText, passwordInField)) {
                    this.dispose();
                    try {
                        Game game = new Game();
                    } catch (Exception ex) {
                        throw new RuntimeException(ex);
                    }
                    long start = System.currentTimeMillis();
                    Time.getstart(start);

                    Music.music();

                    System.out.println("欢迎！");
                } else {
                    JOptionPane.showMessageDialog(this, "密码错误", "账号错误", JOptionPane.ERROR_MESSAGE);
                    System.out.println("密码错误");
                    passwordField.setText("");
                    usernameField.setText("");
                    System.out.println("欢迎！");
                }
            } catch (ClassNotFoundException ex) {
                ex.printStackTrace();
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void actionPerformed(ActionEvent e) {
        String passwordInField = new String(passwordField.getPassword());//作为输入的值，password并不是String
        String usernameFieldText = usernameField.getText();


        try {
            if (getUser(usernameFieldText, passwordInField)) {
                this.dispose();
                try {
                    Game game = new Game();
                } catch (Exception ex) {
                    throw new RuntimeException(ex);
                }
                long start = System.currentTimeMillis();
                Time.getstart(start);

                Music.music();

                System.out.println("欢迎！");
            } else {
                JOptionPane.showMessageDialog(this, "密码错误", "账号错误", JOptionPane.ERROR_MESSAGE);
                System.out.println("密码错误");
                passwordField.setText("");
                usernameField.setText("");
                System.out.println("欢迎！");
            }
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {
        register.setForeground(Color.cyan);
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        register.setForeground(Color.black);
        try {
            RegisterPage registerPage = new RegisterPage();
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        register.setForeground(Color.black);
    }

    @Override
    public void mouseExited(MouseEvent e) {
        register.setForeground(Color.red);
    }
}
```

登录界面

设置按钮画画没什么意思_(-,-)_

###### 设置字体画面

```java
 public login() throws Exception {

        usernameField.setBounds(270, 50, 250, 50);
        passwordField.setBounds(270, 175, 250, 50);
        usernameLabel.setBounds(50, 50, 200, 50);
        passwordLabel.setBounds(50, 175, 200, 50);

        usernameField.setFont(new Font("微雅软黑", Font.PLAIN, 25));
        passwordField.setFont(new Font("微软雅黑", Font.PLAIN, 25));
        passwordField.addKeyListener(this);

        usernameLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        usernameLabel.setForeground(Color.cyan);

        passwordLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        passwordLabel.setForeground(Color.cyan);

        firstButton.setBounds(120, 280, 350, 80);
        firstButton.setFont(new Font("Goudy Stout", Font.PLAIN, 25));
        firstButton.addActionListener(this);

        hm.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON); // 定义是否有下划线
        hm.put(TextAttribute.SIZE, 12); // 定义字号
        hm.put(TextAttribute.FAMILY, "Simsun"); // 定义字体名
        Font font = new Font(hm); // 生成字号为12，字体为宋体，字形带有下划线的字体

        register.setBounds(140, 380, 210, 20);
        register.setForeground(Color.RED);
        register.setFont(font);
        register.addMouseListener(this);

        picture.setBounds(0, 0, 600, 500);

        componont();
        //设置窗口属性
        Image image = ImageIO.read(new File("file/txz/icon.jpg"));

        this.setIconImage(image);
        this.setTitle("firstwindow");
        this.setSize(620, 490);
        this.setResizable(false);
        this.setLocationRelativeTo(null);
        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        this.setLayout(null);
        this.setVisible(true);
    }
```

###### mysql登录连接

```java
 private boolean getUser(String usernameField, String passwordField) throws ClassNotFoundException, SQLException {
        Connection connection = null;
        Statement statement = null;
        ResultSet rs = null;

        try {

            Class.forName("com.mysql.cj.jdbc.Driver");//8.0版本写法，5.0版本好像不用cj

            String url = "jdbc:mysql://localhost:3306/user?useSSL=FALSE&serverTimezone=UTC";
            /*如果要远程连接需要开放需要连接主机的3306端口
            并且将localhost改为主机的ipv4地址*/
            //user不是固定写法，写自己要连的库的名字
            String user = "root";
            String password = "*********";//输入自己的密码

            connection = DriverManager.getConnection(url, user, password);//（地址，用户，密码）
            statement = connection.createStatement();

            String sql = ("select * from user where name='" + usernameField + "' ");//查找是否有同名

            rs = statement.executeQuery(sql);

            if (rs.next()) {
                String ps = rs.getString("password");
                if (ps.equals(passwordField)) {
                    return true;
                }
            }
            connection.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }//释放内存

        }
        return false;
    }
```

这个地方需要导入

mysql -connector-j-8.0.31.jar

看自己的mysql版本决定

```java
 finally {
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
            }//释放内存
        }
```

释放内存，没什么好说的

#### 10.RegisterPage

```java
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.File;
import java.sql.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegisterPage extends JFrame implements ActionListener, KeyListener {

    ImageIcon box = new ImageIcon("file/txz/box.jpg");
    JTextField userName = new JTextField();
    JPasswordField passWord = new JPasswordField();
    JPasswordField repassWord = new JPasswordField();

    JLabel useLabel = new JLabel("Username");
    JLabel passLabel = new JLabel("Password");

    JLabel rewrite = new JLabel("rewrite");
    JLabel picture = new JLabel(box);

    JButton signUP = new JButton("Sign Up");

    public RegisterPage() throws Exception {
        userName.setBounds(270, 85, 250, 40);
        passWord.setBounds(270, 165, 250, 40);
        repassWord.setBounds(270, 245, 250, 40);

        repassWord.addKeyListener(this);

        useLabel.setBounds(50, 85, 200, 40);
        passLabel.setBounds(50, 165, 200, 40);
        rewrite.setBounds(50, 245, 200, 40);


        userName.setFont(new Font("微雅软黑", Font.PLAIN, 25));
        passWord.setFont(new Font("微软雅黑", Font.PLAIN, 25));
        repassWord.setFont(new Font("微软雅黑", Font.PLAIN, 25));

        useLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        useLabel.setForeground(Color.cyan);
        passLabel.setFont(new Font("04b30", Font.PLAIN, 25));
        passLabel.setForeground(Color.cyan);
        rewrite.setFont(new Font("04b30", Font.PLAIN, 25));
        rewrite.setForeground(Color.cyan);

        picture.setBounds(0, 0, 600, 500);

        signUP.setBounds(120, 330, 350, 50);
        signUP.setFont(new Font("Goudy Stout", Font.PLAIN, 25));
        signUP.addActionListener(this);

        componont();

        Image image = ImageIO.read(new File("file/txz/icon.jpg"));
        this.setIconImage(image);

        this.setTitle("Register");
        this.setSize(620, 490);
        this.setLocationRelativeTo(null);
        this.setResizable(false);
        this.setLayout(null);
        this.setVisible(true);
    }

    private void componont() {
        this.add(userName);
        this.add(passWord);
        this.add(repassWord);
        this.add(useLabel);
        this.add(passLabel);
        this.add(rewrite);
        this.add(signUP);
        this.add(picture);
    }

    public boolean zhengZhe(String mima) throws Exception {
        Pattern pattern = Pattern.compile("^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$");//java 中正则起手式

        Matcher m = pattern.matcher(mima);

        return m.matches();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        String usernameinText = userName.getText();
        String passwordInField = new String(passWord.getPassword());
        String repasswordInField = new String(repassWord.getPassword());

        try {
            if (!zhengZhe(passwordInField)) {
                JOptionPane.showMessageDialog(this, "密码需包含英文数字和至少一个特殊字符且不少于8位","格式错误", JOptionPane.ERROR_MESSAGE);
                System.out.println("密码错误");
                passWord.setText("");
                repassWord.setText("");
                System.out.println("欢迎！");
                return;
            }
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }

        if (passwordInField.equals(repasswordInField)) {
            try {
                setUser(usernameinText, passwordInField);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        } else {
            JOptionPane.showMessageDialog(this, "密码与重复输入密码不一致。", "推箱子注册", JOptionPane.ERROR_MESSAGE);
        }
    }

    public void setUser(String user1, String password1) throws ClassNotFoundException, SQLException {
        Connection connection=null;
        Statement statement = null;
        ResultSet rs=null;
        try {
            String all = "\'" + user1 + "\'" + "," + "\'" + password1 + "\'";

            Class.forName("com.mysql.cj.jdbc.Driver");

            String url = "jdbc:mysql://localhost:3306/user?useSSL=FALSE&serverTimezone=UTC";
            String user = "root";
            String password = "mysql$yingzhe";

            connection = DriverManager.getConnection(url, user, password);
            statement = connection.createStatement();

            rs=statement.executeQuery("select * from user where name='"+user1+"'");

            if(rs.next())//next移动，查询到记录返回true
            {  JOptionPane.showMessageDialog(this, "用户名存在", "注册", JOptionPane.ERROR_MESSAGE);}
            else {
                String sql = "insert into user (name ,password) value " + "(" + all + ")";

                System.out.println(sql);

                statement.executeUpdate(sql);
                JOptionPane.showMessageDialog(this, "注册成功，请返回登录界面。", "推箱子注册", JOptionPane.INFORMATION_MESSAGE);
            }

            if (connection == null) {
                System.out.println("连接失败");
            } else {
                System.out.println("连接成功");
            }
            connection.close();
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (statement!=null){
                statement.close();
            }if (rs!=null){
                rs.close();
            }if (connection != null){
                connection.close();
            }//释放内存
        }
    }

    public static void main(String[] args) throws Exception{
        new RegisterPage();
    }

    @Override
    public void keyTyped(KeyEvent e) {

    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode()==KeyEvent.VK_ENTER){
            String usernameinText = userName.getText();
            String passwordInField = new String(passWord.getPassword());
            String repasswordInField = new String(repassWord.getPassword());

            try {
                if (!zhengZhe(passwordInField)) {
                    JOptionPane.showMessageDialog(this, "密码需包含英文数字和至少一个特殊字符且不少于8位","格式错误", JOptionPane.ERROR_MESSAGE);
                    System.out.println("密码错误");
                    passWord.setText("");
                    repassWord.setText("");
                    System.out.println("欢迎！");
                    return;
                }
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }

            if (passwordInField.equals(repasswordInField)) {
                try {
                    setUser(usernameinText, passwordInField);
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            } else {
                JOptionPane.showMessageDialog(this, "密码与重复输入密码不一致。", "推箱子注册", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {

    }
}

```

注册界面

没什么要说的，就是重复登录界面操作

正则

```java
 public boolean zhengZhe(String mima) throws Exception {
        Pattern pattern = Pattern.compile("^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$");//java 中正则起手式

        Matcher m = pattern.matcher(mima);

        return m.matches();
    }
```

这东西什么语言都一样

解释下"^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$"

^$写上就完了，固定格式

（）（）（）三个括号之间是并列关系不分先后

- 开始位置：^
- 至少包含一个字母：(?=.*[A-Za-z])
- 至少包含一个数字：(?=.*\d)
- 至少包含一个特殊字符：(?=.*[@$!%*#?&])
- 由字母、数字和特殊字符组成：[A-Za-z\d@$!%*#?&]
- 长度至少为8个字符：{8,}
- 结束位置：$

及"密码需包含英文数字和至少一个特殊字符且不少于8位“ 这东西用chatgpt写就完了，谁自己想啊（bushi）

#### 11.WinFrame

```java
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.File;

public class WinFrame extends JFrame implements ActionListener {

    ImageIcon back = new ImageIcon("file/txz/back.jpg");
    JLabel background = new JLabel(back);

    JLabel passtime = new JLabel("通关时间:");
    JLabel username = new JLabel("用户   :");

    JLabel ptText = new JLabel(Time.getDur()+"s");
    JLabel usText = new JLabel(login.getUser());

    JButton ntbutton = new JButton("下一关");
    JButton replay = new JButton("重玩");

    public WinFrame() throws Exception {
        background.setBounds(0, 0, 450, 300);

        passtime.setBounds(25, 120, 130, 40);//45,120,110,40
        username.setBounds(50, 40, 110, 40);//20,40,130,40

        passtime.setFont(new Font("茶末余香行书", Font.PLAIN, 30));
        passtime.setForeground(Color.orange);

        username.setFont(new Font("茶末余香行书", Font.PLAIN, 30));
        username.setForeground((Color.orange));

        ptText.setBounds(175, 120, 200, 40);//165,120,200,40
        usText.setBounds(175, 25, 200, 60);//165,40,200,40

        usText.setFont(new Font("茶末余香行书", Font.PLAIN, 40));
        usText.setForeground((Color.orange));

        ptText.setFont(new Font("茶末余香行书", Font.PLAIN, 20));
        ptText.setForeground((Color.orange));

        ntbutton.setBounds(300, 190, 100, 50);
        replay.setBounds(80, 190, 100, 50);

        ntbutton.addActionListener(this);
        replay.addActionListener(this);


        this.setSize(450, 300);
        this.setTitle("推箱子");
        this.setLocationRelativeTo(null);
        BufferedImage image = ImageIO.read(new File("file/txz/icon.jpg"));
        this.setResizable(false);
        this.setLayout(null);
        this.setIconImage(image);

        componont();

        this.setVisible(true);
    }

    private void componont() {
        add(passtime);
        add(username);
        add(ptText);
        add(usText);
        add(ntbutton);
        add(replay);
        add(background);
    }

    public static void main(String[] args) throws Exception {
        new WinFrame();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();

        if (source == ntbutton) {
            Gamepanel.getGamepanel().setEnabled(true);
            Level.Level++;
            Gamepanel.getGamepanel().readMap(Level.Level);
            this.dispose();
        } else if (source == replay) {
            Gamepanel.getGamepanel().setEnabled(true);
            Gamepanel.getGamepanel().tempmap = Gamepanel.getGamepanel().getMap();
            Gamepanel.getGamepanel().readMap(Level.Level);
            this.dispose();
        }

    }
}

```

通过一关界面

#### 12.WInframe2

```java
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.File;

public class WinFrame2 extends JFrame implements ActionListener{
    ImageIcon back = new ImageIcon("file/txz/back.jpg");
    JLabel background =new JLabel(back);

    JLabel passtime = new JLabel("通关时间:");
    JLabel username = new JLabel("用户   :");

    JLabel ptText = new JLabel(Time.getDur()+"s");
    JLabel usText = new JLabel(login.getUser());

    JButton wobutton = new JButton("制作者名单");
    JButton replay   = new JButton("重玩");

    public WinFrame2() throws Exception {
        background.setBounds(0, 0, 450, 300);

        passtime.setBounds(25, 120, 130, 40);//45,120,110,40
        username.setBounds(50, 40, 110, 40);//20,40,130,40

        passtime.setFont(new Font("茶末余香行书", Font.PLAIN, 30));
        passtime.setForeground(Color.orange);

        username.setFont(new Font("茶末余香行书", Font.PLAIN, 30));
        username.setForeground((Color.orange));

        ptText.setBounds(175, 120, 200, 40);//165,120,200,40
        usText.setBounds(175, 25, 200, 60);//165,40,200,40

        ptText.setFont(new Font("茶末余香行书", Font.PLAIN, 20));
        ptText.setForeground((Color.orange));

        usText.setFont(new Font("茶末余香行书", Font.PLAIN, 40));
        usText.setForeground((Color.orange));

        wobutton.setBounds(300,190,100,50);
        replay.setBounds(80,190,100,50);

        wobutton.addActionListener(this);
        replay.addActionListener(this);


        this.setSize(450, 300);
        this.setTitle("推箱子");
        this.setLocationRelativeTo(null);
        BufferedImage image = ImageIO.read(new File("file/txz/icon.jpg"));
        this.setResizable(false);
        this.setLayout(null);
        this.setIconImage(image);

        componont();

        this.setVisible(true);
    }

    private void componont(){
        add(passtime);
        add(username);
        add(ptText);
        add(usText);
        add(wobutton);
        add(replay);
        add(background);
    }

    public static void main(String[] args) throws Exception {
        new WinFrame2();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        if (source==wobutton){
            Worker.getWorker();
            this.dispose();
        }else if (source==replay){
            Gamepanel.getGamepanel().setEnabled(true);
            Gamepanel.getGamepanel().tempmap=Gamepanel.getGamepanel().getMap();
            Gamepanel.getGamepanel().readMap(Level.Level);
            this.dispose();
        }

    }
}

```

全部通关界面

#### 13.Muscle

```java

import org.jaudiotagger.audio.AudioFileIO;
import org.jaudiotagger.audio.mp3.MP3AudioHeader;
import org.jaudiotagger.audio.mp3.MP3File;

import javax.sound.sampled.*;
import java.io.*;

public class Music {
    public static void music() {
        String filepath = "file/music/bg1.wav";
        MusicStuff musicObject = new MusicStuff();
        musicObject.playMusic(filepath);
    }

    public static void main(String[] args) {
        music();
    }

/*    public static void main(String[] args) throws IOException, UnsupportedAudioFileException, LineUnavailableException {
        File file = new File("file/music/bg1.mp3");

        InputStream is = new FileInputStream(file);

        AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(is);//音频输入

        AudioFormat audioFormat = audioInputStream.getFormat();//MP3格式

        AudioFormat decodeFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
                audioFormat.getSampleRate(), 16, audioFormat.getChannels(),
                audioFormat.getChannels() * 2, audioFormat.getSampleRate(), false);
        AudioInputStream decodeAudioStream = AudioSystem.getAudioInputStream(decodeFormat, audioInputStream);

        DataLine.Info info = new DataLine.Info(SourceDataLine.class, decodeFormat);
        SourceDataLine line = (SourceDataLine) AudioSystem.getLine(info);//创建源数据行
        line.open(decodeFormat);

        line.start();

        byte[] AUDIO_BUFER = new byte[100];
        int readLenth = 0;
        while (true) {
            readLenth = decodeAudioStream.read(AUDIO_BUFER, 0, AUDIO_BUFER.length);
            if (readLenth < 0){
                break;
            }
            line.write(AUDIO_BUFER,0,readLenth);
        }

        line.drain();//清空缓冲区
        line.stop();
        line.close();

    }*/
     String path ="file/music/bg1.mp3";

    public  void getMusic()throws IOException, UnsupportedAudioFileException, LineUnavailableException{
        File file = new File(path);

        InputStream is = new FileInputStream(file);

        AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(is);//音频输入

        AudioFormat audioFormat = audioInputStream.getFormat();//MP3格式

        AudioFormat decodeFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
                audioFormat.getSampleRate(), 16, audioFormat.getChannels(),
                audioFormat.getChannels() * 2, audioFormat.getSampleRate(), false);
        AudioInputStream decodeAudioStream = AudioSystem.getAudioInputStream(decodeFormat, audioInputStream);

        DataLine.Info info = new DataLine.Info(SourceDataLine.class, decodeFormat);
        SourceDataLine line = (SourceDataLine) AudioSystem.getLine(info);//创建源数据行
        line.open(decodeFormat);

        line.start();

        byte[] AUDIO_BUFER = new byte[100];
        int readLenth = 0;
        while (true) {
            readLenth = decodeAudioStream.read(AUDIO_BUFER, 0, AUDIO_BUFER.length);
            if (readLenth < 0){
                break;
            }
            line.write(AUDIO_BUFER,0,readLenth);
        }

        line.drain();//清空缓冲区
        line.stop();
        line.close();

    }

    public static void getMp3Duration(String filePath) {
        try {
            File mp3File = new File(filePath);
            MP3File f = (MP3File) AudioFileIO.read(mp3File);
            MP3AudioHeader audioHeader = (MP3AudioHeader) f.getAudioHeader();
            System.out.println("时长:" + Float.parseFloat(audioHeader.getTrackLength() + ""));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

//    public static void main(String[] args) throws UnsupportedAudioFileException, LineUnavailableException, IOException {
//     getMusic();
//    }
}

```

上面大部分是无效代码

本来想模拟输入流，然后就没有然后了

有用的只有下面一个方法，java本身好像自己带着有

```java
public static void music() {
        String filepath = "file/music/bg1.wav";
        MusicStuff musicObject = new MusicStuff();
        musicObject.playMusic(filepath);
    }
```

14.MusicStuff

```java
import javax.sound.sampled.*;
import java.io.*;
public class MusicStuff {
    void playMusic(String musicLocation)
    {
        try
        {
            File musicPath = new File(musicLocation);

            if(musicPath.exists())
            {
                System.out.println("play");
                AudioInputStream audioInput = AudioSystem.getAudioInputStream(musicPath);
                Clip clip = AudioSystem.getClip();
                clip.open(audioInput);
                clip.start();
                clip.loop(Clip.LOOP_CONTINUOUSLY);
            }
            else
            {
                System.out.println("can't find file");
            }
        }
        catch(Exception ex)
        {
            ex.printStackTrace();
        }
    }
}

```

实现循环播放，好像只能放wav格式。没有线程阻塞。
